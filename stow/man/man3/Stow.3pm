.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Stow 3pm"
.TH Stow 3pm "2018-09-23" "perl v5.26.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Stow \- manage the installation of multiple software packages
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    my $stow = new Stow(%$options);
\&
\&    $stow\->plan_unstow(@pkgs_to_unstow);
\&    $stow\->plan_stow  (@pkgs_to_stow);
\&
\&    my %conflicts = $stow\->get_conflicts;
\&    $stow\->process_tasks() unless %conflicts;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the backend Perl module for \s-1GNU\s0 Stow, a program for managing
the installation of software packages, keeping them separate
(\f(CW\*(C`/usr/local/stow/emacs\*(C'\fR vs. \f(CW\*(C`/usr/local/stow/perl\*(C'\fR, for example)
while making them appear to be installed in the same place
(\f(CW\*(C`/usr/local\*(C'\fR).
.PP
Stow doesn't store an extra state between runs, so there's no danger
of mangling directories when file hierarchies don't match the
database. Also, stow will never delete any files, directories, or
links that appear in a stow directory, so it is always possible to
rebuild the target tree.
.SH "CONSTRUCTORS"
.IX Header "CONSTRUCTORS"
.SS "new(%options)"
.IX Subsection "new(%options)"
\fIRequired options\fR
.IX Subsection "Required options"
.IP "\(bu" 4
dir \- the stow directory
.IP "\(bu" 4
target \- the target directory
.PP
\fINon-mandatory options\fR
.IX Subsection "Non-mandatory options"
.PP
See the documentation for the \fIstow\fR \s-1CLI\s0 front-end for information on these.
.IP "\(bu" 4
conflicts
.IP "\(bu" 4
simulate
.IP "\(bu" 4
verbose
.IP "\(bu" 4
paranoid
.IP "\(bu" 4
compat
.IP "\(bu" 4
test_mode
.IP "\(bu" 4
adopt
.IP "\(bu" 4
no-folding
.IP "\(bu" 4
ignore
.IP "\(bu" 4
override
.IP "\(bu" 4
defer
.PP
N.B. This sets the current working directory to the target directory.
.SS "set_stow_dir([$dir])"
.IX Subsection "set_stow_dir([$dir])"
Sets a new stow directory.  This allows the use of multiple stow
directories within one Stow instance, e.g.
.PP
.Vb 4
\&    $stow\->plan_stow(\*(Aqfoo\*(Aq);
\&    $stow\->set_stow_dir(\*(Aq/different/stow/dir\*(Aq);
\&    $stow\->plan_stow(\*(Aqbar\*(Aq);
\&    $stow\->process_tasks;
.Ve
.PP
If \f(CW$dir\fR is omitted, uses the value of the \f(CW\*(C`dir\*(C'\fR parameter passed
to the \fInew()\fR constructor.
.SH "METHODS"
.IX Header "METHODS"
.SS "plan_unstow(@packages)"
.IX Subsection "plan_unstow(@packages)"
Plan which symlink/directory creation/removal tasks need to be executed
in order to unstow the given packages.  Any potential conflicts are then
accessible via \fIget_conflicts()\fR.
.SS "plan_stow(@packages)"
.IX Subsection "plan_stow(@packages)"
Plan which symlink/directory creation/removal tasks need to be executed
in order to stow the given packages.  Any potential conflicts are then
accessible via \fIget_conflicts()\fR.
.SS "\fIget_conflicts()\fP"
.IX Subsection "get_conflicts()"
Returns a nested hash of all potential conflicts discovered: the keys
are actions ('stow' or 'unstow'), and the values are hashrefs whose
keys are stow package names and whose values are conflict
descriptions, e.g.:
.PP
.Vb 8
\&    (
\&        stow => {
\&            perl => [
\&                "existing target is not owned by stow: bin/a2p"
\&                "existing target is neither a link nor a directory: bin/perl"
\&            ]
\&        }
\&    )
.Ve
.SS "\fIget_conflict_count()\fP"
.IX Subsection "get_conflict_count()"
Returns the number of conflicts found.
.SS "\fIget_tasks()\fP"
.IX Subsection "get_tasks()"
Returns a list of all symlink/directory creation/removal tasks.
.SS "\fIget_action_count()\fP"
.IX Subsection "get_action_count()"
Returns the number of actions planned for this Stow instance.
.SS "invalidate_memoized_regexp($file)"
.IX Subsection "invalidate_memoized_regexp($file)"
For efficiency of performance, regular expressions are compiled from
each ignore list file the first time it is used by the Stow process,
and then memoized for future use.  If you expect the contents of these
files to change during a single run, you will need to invalidate the
memoized value from this cache.  This method allows you to do that.
.SH "BUGS"
.IX Header "BUGS"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
